



Класс GCHeap определен в gc/gcimpl.h 

GCHeap -> IGCHeapInternal -> IGCHeap

GCHeap - всегда есть один экземпляр этого высокоуровневого API - он используется
как интерфейс между сборщиком мусора и механизмом исполнения
(они оба хранят глобальные экземпляры g_pGCHeap и g_theGCHeap). 


IGCHeapInternal определен в gc/gc.h 

IGCHeap определен в gc/gcinterface.h

IGCHeap is the interface that the VM will use when interacting with the GC.


В классе IGCHeapInternal определены API:

unsigned GetMaxGeneration() - возвращает количество поколений


В классе GCHeap определен метод:

Object* Alloc (gc_alloc_context* acontext, size_t size, uint32_t flags);



Класс Object определен в  vm/object.h

Object - это представление управляемого объекта в куче GC.

gc_alloc_context определен в  gc/gcinterface.h
И хранит контекст выделения

Куча для маленьких объектов (Small Objects Heap) и куча для больших объектов (Large Objects Heap, LOH)

GCHeap::Alloc имплементирован в gc/gc.cpp



Структура static_data определена в gc/gcpriv.h

min_size - минимальный так называемый бюджет выделения. Строго связан с размером кэша процессора
max_size - максимальный бюджет распределения

fragmentation_limit и fragmentation_burden_limit - используется, когда решая, должны ли мы сжиматься,

limit и max limit - используется для расчета роста генерации бюджет распределения

time_clock - время, по истечении которого собирать генерацию, по производительности рассчитывает (см. QueryPerformanceCounter)

gc_clock - количество GC, после которых нужно собрать поколение.

Максимальный бюджет распределения для поколения 2 и кучи больших объектов ограничены только максимальным пределом адреса (SSIZE_T_MAX - половина размер слова) - это также имеет смысл, так как все долгожители
объекты собираются в этих двух.


Поколение 0. Это самое молодое поколение содержит короткоживущие объекты. Примером короткоживущего объекта является временная переменная. Сборка мусора чаще всего выполняется в этом поколении.

Вновь распределенные объекты образуют новое поколение объектов и неявно являются сборками поколения 0, если они не являются большими объектами, в противном случае они попадают в кучу больших объектов в сборке поколения 2.

Большинство объектов уничтожаются при сборке мусора для поколения 0 и не доживают до следующего поколения.

Поколение 1. Это поколение содержит коротко живущие объекты и служит буфером между короткоживущими и долгоживущими объектами.

Поколение 2. Это поколение содержит долгоживущие объекты. Примером долгоживущих объектов служит объект в серверном приложении, содержащий статические данные, которые существуют в течение длительности процесса.

Так как объекты в поколениях 0 и 1 являются короткоживущими, эти поколения называются эфемерными поколениями.


GCInfo в jit/jitgcinfo.h

Класс gc_heap определен в gc/gcpriv.h

INT_CONFIG(LatencyLevel...)

Класс GCConfig определен в gc/gcconfig.h

src/vm/gcheaputilities.cpp

GCHeapUtilities::LoadAndInitialize()

vm/ceemain.cpp

InitializeGarbageCollector

IGCHandleManager в gc/gcinterface.h отвечает за загрузку методов gc


GCToEEInterface::GcScanRoots в vm/gcenv.ee.cpp

Механизм выполнения (Execution Engine), или EE - компонент CLR, отвечающий за выполнение программ. 
