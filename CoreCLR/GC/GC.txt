Два режима - рабочая станция и сервер. Режимы лучше рассматривать как
несколько двух, заметно отличающихся наборов конфигураций GC. 

Режим рабочей станции был разработан главным образом для обеспечения оперативности, необходимой для интерактивных приложений на основе пользовательского интерфейса. Интерактивность подразумевает как можно более короткие паузы в приложении. Мы не хотим останавливать пользовательский интерфейс, потому что был запущен длинный GC. Более длинные паузы могут повлиять на плавность и отзывчивость всех действий в целом. 

GC будут происходить чаще - но благодаря этому у них будет меньше работы (меньше объектов создано, поэтому меньше может стать мусор).

В качестве побочного эффекта от вышеперечисленного, использование памяти будет ниже - чаще GC означают, что память восстанавливается более агрессивно, и нет большого количества «зависшего» мусора.

В качестве побочного эффекта от вышеперечисленного, использование памяти будет ниже - чаще GC означают, что память восстанавливается более агрессивно, и нет большого количества «зависшего» мусора.

Существует одна управляемая куча - поскольку настольные приложения обычно выполняют одно основное действие, связанное с действиями пользователя, нет необходимости в специальном распараллеливании их работы. Более того, этот режим предполагает, что на компьютере запущено много приложений.

Каждое из них использует некоторые ядра процессора и память. Следовательно, нет необходимости или особенно желательно умножать потоки GC, которые одновременно обрабатывают несколько куч. С самого начала режим рабочей станции был разработан так, чтобы одна управляемая куча обрабатывалась одним потоком за раз.


В режиме сервера

GC будут происходить реже - но это может означать более длительные паузы, потому что между GC было создано больше объектов. 1 Это, однако, позволяет нам повысить пропускную способность, поскольку мы можем обрабатывать параллельно несколько запросов в течение более длительного времени без пауз.

В качестве побочного эффекта вышеизложенного использование памяти будет выше - реже GC означают, что между ними будет собираться больше «зависшего» мусора. Это подразумевает больший рабочий набор, чем в случае режима рабочей станции. Однако предполагается, что общепринятые «серверы» оснащены большим объемом памяти, поэтому это не такая большая проблема.

Существует несколько управляемых куч - это обеспечивает относительную масштабируемость на мощность машины. Если GC уже происходит, мы хотим сделать это Быстро настолько, насколько это возможно. Параллельная обработка многих куч быстрее, чем одной большой кучи. 2 Более того, серверные приложения часто размещены на выделенных серверах, так что они могут совершенно свободно потреблять все доступные для них ядра.

Лучше сначала провести дефрагментацию, если нам не хватает места для эфемерного поколения, но у нас достаточно фрагментации, чтобы восполнить это в не эфемерном поколении. По сути, мы торгуем поколением 2 за то, что ему приходится расширять кучу в эфемерных коллекциях.

Принимая во внимание вышеизложенное, часто режим сервера будет потреблять больше памяти, но даст вам меньше времени в GC.

Класс GCHeap определен в gc/gcimpl.h 

GCHeap -> IGCHeapInternal -> IGCHeap

GCHeap - всегда есть один экземпляр этого высокоуровневого API - он используется
как интерфейс между сборщиком мусора и механизмом исполнения
(они оба хранят глобальные экземпляры g_pGCHeap и g_theGCHeap). 

gc/gcsvr.cpp определяет константу SERVER_GC и пространство имен SVR:

gc/gcwks.cpp определяет WKS пространство имен

Два режима работы относительно потоков - конкурентный и неконкурентный.

Неконкурентная версия GC существует с самого начала .NET, как для рабочих станций, так и для режимов сервера. Все управляемые пользовательские потоки приостановлены во время GC. Концептуально это действительно просто - мы должны остановить все пользовательские потоки, выполнить сборку мусора и возобновить пользовательские потоки.

Конкурентная сборщик мусора, как и следовало ожидать, выполняется во время работы обычных пользовательских потоков. Это делает его более сложным как с точки зрения концепции, так и с точки зрения реализации. Должна быть обеспечена дополнительная синхронизация между пользовательскими потоками и Collector во время его работы, чтобы оба имели четкое представление о реальности и не вызывали серьезных проблем (например, изменение собранных объектов или коллекционирование объектов, которые все еще живут). Такая синхронизация, очевидно, нелегко осуществить, особенно из-за желаемой высокой производительности в целом.

Конкурентная версия заключена в Директива препроцессора BACKGROUND_GC


Из предыдущих разделов становится ясно, что у нас есть две ортогональные настройки с двумя возможными значениями каждая. Это дает нам четыре возможных режима работы GC. Это в основном все, что мы можем установить с точки зрения GC.

Вы также можете установить эти режимы при размещении CLR внутри собственного процесса через интерфейс ICLRRuntimeHost. 


mark_array в gc/gcpriv.h

c_mark_list в gc/gcpriv.h


Уже посещенный объект добавил ссылку на недоступный в противном случае объект, например, путем создания нового или
переназначение ссылки с другого объекта - это опасно. Это может означать, что у нас не будет возможности посетить (пометить) объект, который после такого изменения достижимо от другого объекта. Это так называемая проблема «потерянного объекта». Правильная одновременная маркировка реализация не должна допускать возникновения таких ситуаций.

gc_heap::background_mark_phase () в gc/gc.cpp

c_mark_list заполнен с помощью метода gc_heap :: background_promote_callback 


gc_heap::mark_phase в gc/gc.cpp

Она вызывает GCScan::GcScanRoots которая определена в gc/gcscan.cpp

GCScan::GcScanRoots вызывает GCToEEInterface::GcScanRoots

События в GC - gc/gcevents.h


MULTIPLE_HEAPS определена в режиме SERVER_GC

IGCHeapInternal определен в gc/gc.h 

IGCHeap определен в gc/gcinterface.h

IGCHeap is the interface that the VM will use when interacting with the GC.


В классе IGCHeapInternal определены API:

unsigned GetMaxGeneration() - возвращает количество поколений


В классе GCHeap определен метод:

Object* Alloc (gc_alloc_context* acontext, size_t size, uint32_t flags);

gc_heap::n_heaps - Если определено MULTIPLE_HEAPS

Класс Object определен в  vm/object.h

Object - это представление управляемого объекта в куче GC.

gc_alloc_context определен в  gc/gcinterface.h
И хранит контекст выделения

Куча для маленьких объектов (Small Objects Heap) и куча для больших объектов (Large Objects Heap, LOH)

GCHeap::Alloc имплементирован в gc/gc.cpp

GetCacheSizePerLogicalCpu - для min_size

Структура static_data определена в gc/gcpriv.h

min_size - минимальный так называемый бюджет выделения. Строго связан с размером кэша процессора
max_size - максимальный бюджет распределения

Максимальный бюджет распределения для поколения 2 и кучи больших объектов ограничены только максимальным пределом адреса (SSIZE_T_MAX - половина размер слова) - это также имеет смысл, так как все долгожители объекты собираются в этих двух.
Такое пространство должно быть логически «неограниченным» для обработки любого сценария использования памяти. Очевидно, что эти размеры ограничены физическими ресурсами (оперативная память и файлы подкачки, ограничения адресации).

fragmentation_limit и fragmentation_burden_limit - используется, когда решая, должны ли мы сжиматься,


коэффициент фрагментации - это соотношение вышеуказанного общего непригодного размер фрагментации к размеру всего поколения. Это значение то значение рассчитывается из fragmentation_burden_limit  удваивая его, но не превышая 75%


limit и max limit - используется для расчета роста генерации бюджет распределения

Общая иллюстрация функции, описывающей новый бюджет распределения с точки зрения выживаемости, показана на рисунке 7-13. Крутизна наклона, порог, с которого начинается максимальный размер генерации, и менее важные свойства таких функций зависят от предела статических параметров и max_limit, представленных в таблицах 7-1 и 7-2. Чем меньше значения этих пределов, тем круче наклон и тем быстрее устанавливается максимальное значение.

настройка по времени  
если с момента последнего gc прошло достаточно времени
и число gc слишком мало (1/10 от более низкого поколения), затем собираем
Это также должно быть включено, если у нас есть проблемы с памятью

time_clock - время, по истечении которого собирать генерацию, по производительности рассчитывает (см. QueryPerformanceCounter)

gc_clock - количество GC, после которых нужно собрать поколение.

Динамические данные представляют текущее состояние управляемой кучи с точки зрения поколения. Они обновляются во время GC для расчета данных, необходимых для различных решений (в том числе о том, должно ли это сжатие GC или нет, является ли генерация «полной» и должен ли GC запускаться, и так далее, и так далее)

gc_heap :: make_unused_array создание свободного объекта


Поколение 0. Это самое молодое поколение содержит короткоживущие объекты. Примером короткоживущего объекта является временная переменная. Сборка мусора чаще всего выполняется в этом поколении.

Вновь распределенные объекты образуют новое поколение объектов и неявно являются сборками поколения 0, если они не являются большими объектами, в противном случае они попадают в кучу больших объектов в сборке поколения 2.

Большинство объектов уничтожаются при сборке мусора для поколения 0 и не доживают до следующего поколения.

Поколение 1. Это поколение содержит коротко живущие объекты и служит буфером между короткоживущими и долгоживущими объектами.

Поколение 2. Это поколение содержит долгоживущие объекты. Примером долгоживущих объектов служит объект в серверном приложении, содержащий статические данные, которые существуют в течение длительности процесса.

Так как объекты в поколениях 0 и 1 являются короткоживущими, эти поколения называются эфемерными поколениями.

Сообщения типа  GC Heap 0000000000000000 ... в  gc_heap::descr_generations в gc/gc.cpp 


plug - представляет смежную группу отмеченных (достижимых) объектов
gap - представляет смежную группу без пометок (недоступна)
объекты

gc_heap :: plan_phase обнаруживает gap и plug

Если объект закреплен, это, скорее всего, потому, что мы хотим передать его адрес неуправляемому коду 

Превышен бюджет распределения (превышен бюджет поколения) - будет осуждено самое старшее поколение, которое превысило бюджет распределения. Это включает в себя кучу больших объектов, в случае которой поколение 2 будет осуждено (активирует полный GC), но только если фоновый GC еще не запущен. Обратите внимание, что, например, это означает, что старшее поколение может быть осуждено из-за его бюджета распределения, даже если первоначально при распределении объектов было обнаружено только нарушение бюджета поколения 0.

Настройка на основе времени (Time Tuning) - это может быть удивительно, но GC также заботится о соответствующих пропорциях коллекций отдельных поколений на основе временных зависимостей и их подсчета. Это делается, однако, только в режиме рабочей станции, а не в режиме сервера, и только в случае режимов ожидания Interactive или SustainedLowLatency.
GC может решить осудить поколение, если прошло достаточно времени с момента последнего GC этого поколения, и количество GC более низкого поколения превысило определенный порог. 

Эфемерное поколение слишком фрагментировано (Fragmented Ephemeral) - эфемерное поколение, порог фрагментации которого превышение будет осуждено (то есть поколение 0 или 1).
Недостаток места в эфемерном сегменте требует расширения это (Expand Heap) - если нет другого способа соответствовать растущей эфемерности поколения, кроме расширения сегмента, поколение 2 будет осуждается (срабатывание полное, блокировка GC).


Поколение 2 слишком фрагментировано (Fragmented Gen2) - порог фрагментации поколения 2 был превышен, и его следует осудить.

Поколение 2 или LOH слишком мало для выполнения фонового GC (Small Heap) - в таком случае полное блокирование GC будет запущено.

В случае режима с низкой задержкой может быть осуждено только поколение 0 или 1 (отменяя любые предыдущие решения).

общий объем памяти теряется из-за непригодной фрагментации - непригодная фрагментация включает в себя:
неиспользуемое свободное пространство, не управляемое распределителем поколений - это небольшие пробелы, созданные во время подметания (как мы увидим позже), и пространство в эфемерных поколениях, выброшенное после неудачной подгонки (как упоминалось в главе 5, элементы свободного списка в этих поколениях проверяются только один раз и затем отпускаются).

generation_to_condemn в gc.cpp


На самом деле из-за пиннинга существует три вида групп объектов:
plug - представляет группу отмеченных (достижимых) объектов,
pinned plug - представляет группу закрепленных (и, следовательно, помеченных)
объекты,
gap - представляет собой группу неотмеченных (недоступных) объектов.

Гораздо более практичный подход заключается в построении деревьев подключений для последовательных диапазонов адресов. Такой ассортимент называется brick в CLR. Размер блока составляет 2048 B для 32-разрядных и 4096 B для 64-разрядных сред выполнения. Другими словами, каждые 2 или 4 КБ управляемой кучи представлены одним кирпичиком, который содержит информацию о его дереве плагинов. 

GCInfo в jit/jitgcinfo.h

Класс gc_heap определен в gc/gcpriv.h

INT_CONFIG(LatencyLevel...)

Класс GCConfig определен в gc/gcconfig.h

src/vm/gcheaputilities.cpp

GCHeapUtilities::LoadAndInitialize()

vm/ceemain.cpp

InitializeGarbageCollector

IGCHandleManager в gc/gcinterface.h отвечает за загрузку методов gc

init_static_data в gc/gc.cpp

GCToEEInterface::GcScanRoots в vm/gcenv.ee.cpp

Механизм выполнения (Execution Engine), или EE - компонент CLR, отвечающий за выполнение программ. 

IGCToCLR определен в gc/gcinterface.ee.h

 Этот интерфейс предоставляет интерфейс, который GC будет использовать для общения с остальными  механизма исполнения. Все, что делает GC, требует EE чтобы получить информацию или что требуется действие EE, необходимо пройти через этот интерфейс.
